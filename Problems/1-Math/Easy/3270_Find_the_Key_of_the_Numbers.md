<div align="center">

# üß† [3270. Find the Key of the Numbers](https://leetcode.com/problems/find-the-key-of-the-numbers/)

[![LeetCode](https://img.shields.io/badge/LeetCode-Problem%203270-FFA116?style=for-the-badge&logo=leetcode&logoColor=white)](https://leetcode.com/problems/find-the-key-of-the-numbers/)

</div>

---

## üìã Problem Overview

| Property            | Value                                                                          |
| ------------------- | ------------------------------------------------------------------------------ |
| **Difficulty**      | üü¢ **Easy**                                                                    |
| **Acceptance Rate** | `76.1%`                                                                        |
| **Problem Link**    | [Open in LeetCode](https://leetcode.com/problems/find-the-key-of-the-numbers/) |
| **Tags**            | ![Math](https://img.shields.io/badge/-Math-blue?style=flat-square)             |

## Description

<!-- description:start -->

<p>You are given three <strong>positive</strong> integers <code>num1</code>, <code>num2</code>, and <code>num3</code>.</p>

<p>The <code>key</code> of <code>num1</code>, <code>num2</code>, and <code>num3</code> is defined as a four-digit number such that:</p>

<ul>
    <li>Initially, if any number has <strong>less than</strong> four digits, it is padded with <strong>leading zeros</strong>.</li>
    <li>The <code>i<sup>th</sup></code> digit (<code>1 &lt;= i &lt;= 4</code>) of the <code>key</code> is generated by taking the <strong>smallest</strong> digit among the <code>i<sup>th</sup></code> digits of <code>num1</code>, <code>num2</code>, and <code>num3</code>.</li>
</ul>

<p>Return the <code>key</code> of the three numbers <strong>without</strong> leading zeros (<em>if any</em>).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num1 = 1, num2 = 10, num3 = 1000
<strong>Output:</strong> 0
<strong>Explanation:</strong> On padding, <code>num1</code> becomes "0001", <code>num2</code> becomes "0010", and <code>num3</code> remains "1000".
- The 1st digit of the key is min(0, 0, 1)
- The 2nd digit of the key is min(0, 0, 0)
- The 3rd digit of the key is min(0, 1, 0)
- The 4th digit of the key is min(1, 0, 0)
Hence, the key is "0000", i.e. 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num1 = 987, num2 = 879, num3 = 798
<strong>Output:</strong> 777
<strong>Explanation:</strong> For each digit, take the minimum among the three numbers:
- 1st digit: min(9,8,7) = 7
- 2nd digit: min(8,7,9) = 7
- 3rd digit: min(7,9,8) = 7
Key = 777
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> num1 = 1, num2 = 2, num3 = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> After padding: "0001", "0002", "0003". The minimum digit for each position gives key = 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
    <li><code>1 &lt;= num1, num2, num3 &lt;= 9999</code></li>
</ul>

<!-- description:end -->

## ‚è∞ Progress Tracking

| Status           | Date         | Notes                                    |
| ---------------- | ------------ | ---------------------------------------- |
| üéØ **Attempted** | `08-09-2025` | First attempt, understanding the problem |
| ‚úÖ **Solved**    | `08-09-2025` | Successfully implemented solution        |
| üîÑ **Review 1**  | `09-09-2025` | First review, optimization               |
| üîÑ **Review 2**  | `DD-MM-YYYY` | Second review, different approaches      |
| üîÑ **Review 3**  | `DD-MM-YYYY` | Final review, mastery                    |

## üîó Related Problems

| Problem                                                         | Difficulty    | Relationship  |
| --------------------------------------------------------------- | ------------- | ------------- |
| [Largest Number](https://leetcode.com/problems/largest-number/) | üü° **Medium** | Similar logic |

---

## üí° Solutions

### ü•â Approach 1: Brute Force

#### üìù Intuition

> Convert all numbers to strings padded to 4 digits and compare digit by digit to find the minimum digit for each position.

#### üîç Algorithm

```pseudo
function getKey(num1, num2, num3):
    for each number:
        pad with leading zeros to 4 digits
    for i from 0 to 3:
        key_digit[i] = min(num1[i], num2[i], num3[i])
    combine key_digit array into a number
    remove leading zeros
    return number
```

#### üíª Implementation

```cpp
// Brute force approach
class Solution {
public:
    int getKey(int num1, int num2, int num3) {
        auto pad = [](int x) {
            string s = to_string(x);
            while(s.size() < 4) s = "0" + s;
            return s;
        };
        string s1 = pad(num1), s2 = pad(num2), s3 = pad(num3);
        string key = "";
        for(int i = 0; i < 4; i++) {
            char c = min({s1[i], s2[i], s3[i]});
            key += c;
        }
        return stoi(key);
    }
};
```

### ü•à Approach 2: Optimized Solution

#### üìù Intuition

> Instead of converting to strings, extract each digit mathematically using division and modulo, and take the minimum of each corresponding digit.

#### üîç Algorithm

```pseudo
function getKey(num1, num2, num3):
    initialize key_digits array of size 4
    for position from 0 to 3:
        extract digit of num1 at position
        extract digit of num2 at position
        extract digit of num3 at position
        key_digits[position] = min(digit1, digit2, digit3)
    combine key_digits into integer
    return integer
```

#### üíª Implementation

```cpp
// Optimized approach with better complexity
class Solution {
public:
    int getKey(int num1, int num2, int num3) {
        int key = 0;
        for(int i = 0; i < 4; i++) {
            int d1 = (num1 / (int)pow(10, 3-i)) % 10;
            int d2 = (num2 / (int)pow(10, 3-i)) % 10;
            int d3 = (num3 / (int)pow(10, 3-i)) % 10;
            key = key * 10 + min({d1, d2, d3});
        }
        return key;
    }
};
```

### ü•á Approach 3: Optimal Solution ‚≠ê

#### üìù Intuition

> Use precomputed divisors for thousands, hundreds, tens, units to extract digits efficiently without pow. This reduces overhead.

#### üîç Algorithm

```pseudo
function getKey(num1, num2, num3):
    divisors = [1000, 100, 10, 1]
    for i from 0 to 3:
        digit1 = (num1 / divisors[i]) % 10
        digit2 = (num2 / divisors[i]) % 10
        digit3 = (num3 / divisors[i]) % 10
        key = key * 10 + min(digit1, digit2, digit3)
    return key
```

#### üíª Implementation

```cpp
// Most optimal and elegant solution
class Solution {
public:
    int getKey(int num1, int num2, int num3) {
        int divisors[4] = {1000, 100, 10, 1};
        int key = 0;
        for(int i = 0; i < 4; i++) {
            int d1 = (num1 / divisors[i]) % 10;
            int d2 = (num2 / divisors[i]) % 10;
            int d3 = (num3 / divisors[i]) % 10;
            key = key * 10 + min({d1, d2, d3});
        }
        return key;
    }
};
```

## üìä Comparison of Approaches

| Approach       | Time Complexity | Space Complexity | Pros                                              | Cons                                        |
| -------------- | --------------- | ---------------- | ------------------------------------------------- | ------------------------------------------- |
| ü•â Brute Force | O(1)            | O(1)             | Simple and easy to implement using strings        | Slight overhead from string operations      |
| ü•à Optimized   | O(1)            | O(1)             | Avoids strings, uses mathematical operations      | Slightly more complex code than brute force |
| ü•á Optimal ‚≠ê  | O(1)            | O(1)             | Most efficient, no pow function, minimal overhead | Slightly less intuitive than brute force    |

## üéØ Why This is Optimal?

    - Compared to the brute force, mathematical approaches avoid string conversions and function calls like pow, reducing unnecessary computation.
    - Optimal approach reduces overhead by using precomputed divisors for digit extraction.
    - The solution is clean, scalable, and maintains constant time and space complexity

### üîë Key Insights

| #   | Insight                                                     |
| --- | ----------------------------------------------------------- |
| 1   | Padding numbers to 4 digits allows easy comparison          |
| 2   | Digit extraction can be done mathematically without strings |
| 3   | Using precomputed divisors avoids repeated calculations     |

### üí≠ Common Mistakes to Avoid

| #   | Mistake                              | Description                          | How to Avoid                    | Example                                |
| --- | ------------------------------------ | ------------------------------------ | ------------------------------- | -------------------------------------- |
| 1   | Not padding numbers                  | Leads to incorrect digit comparisons | Always pad to 4 digits          | Comparing 1, 10, 1000 without padding  |
| 2   | Mixing string and integer operations | Can cause type errors                | Use consistent type conversions | Concatenating int with string directly |
| 3   | Forgetting leading zeros             | May produce wrong key                | Explicitly pad or handle digits | `0010` vs `10`                         |

### üêõ Implementation Mistakes

| #   | Mistake                                  | Description                         | How to Avoid                                       | Example                                               |
| --- | ---------------------------------------- | ----------------------------------- | -------------------------------------------------- | ----------------------------------------------------- | --- |
| 1   | Using pow incorrectly                    | May get floating-point errors       | Use integer math or precomputed divisors           | `(int)pow(10, i)` returns double, rounding issues     |
| 2   | Overwriting key variable                 | Losing previously calculated digits | Always multiply key by 10 before adding next digit | `key = min(...)` instead of `key = key*10 + min(...)` |
| 3   | Not removing leading zeros when required | Output may have unwanted zeros      | Use `stoi` or integer arithmetic                   | `"0000"` should return `0`                            |     |

### üí≠ Logical Thinking Mistakes

| #   | Mistake                        | Description                           | How to Avoid                                             | Prevention                             |
| --- | ------------------------------ | ------------------------------------- | -------------------------------------------------------- | -------------------------------------- |
| 1   | Confusing digit positions      | Comparing wrong digits across numbers | Map each digit correctly, from most to least significant | Indexing digits incorrectly            |
| 2   | Assuming numbers have 4 digits | Fails for smaller numbers             | Always pad numbers to 4 digits                           | 1, 10, 100 instead of 0001, 0010, 0100 |
| 3   | Misunderstanding min function  | Key calculation is wrong              | Carefully compare each corresponding digit               | Taking min across wrong digits         |

### üéØ Patterns & Techniques Used

| #   | Pattern / Technique     | Application                                            |
| --- | ----------------------- | ------------------------------------------------------ |
| 1   | Digit Extraction        | Extract digits mathematically for comparison           |
| 2   | Padding / Normalization | Ensure numbers have uniform length for easy comparison |
| 3   | Min Function            | Find minimum digit among corresponding positions       |

### üîÑ Follow-up Questions

| #   | Pattern / Technique     | Application                                            |
| --- | ----------------------- | ------------------------------------------------------ |
| 1   | Digit Extraction        | Extract digits mathematically for comparison           |
| 2   | Padding / Normalization | Ensure numbers have uniform length for easy comparison |
| 3   | Min Function            | Find minimum digit among corresponding positions       |

---

<div align="center">

**üéØ Problem 3270 Completed!**

_Happy Coding! üöÄ_

</div>
